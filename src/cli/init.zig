const std = @import("std");
const color = @import("../output/color.zig");
const common = @import("common.zig");
const registry = @import("../lang/registry.zig");
const provider = @import("../lang/provider.zig");
const LanguageProvider = provider.LanguageProvider;

/// Generate zr.toml content from detected languages
fn generateConfigFromDetected(
    allocator: std.mem.Allocator,
    detected: []const registry.DetectedLanguage,
    dir_path: []const u8,
) ![]const u8 {
    var buf = std.ArrayList(u8){};
    defer buf.deinit(allocator);

    const writer = buf.writer(allocator);

    // Header
    try writer.writeAll(
        \\# zr.toml — auto-generated by `zr init --detect`
        \\# Docs: https://github.com/yusa-imit/zr
        \\
        \\[global]
        \\shell = "bash"
        \\
        \\
    );

    // Collect all tasks from all detected languages
    var all_tasks = std.ArrayList(LanguageProvider.TaskSuggestion){};
    defer all_tasks.deinit(allocator);

    for (detected) |lang| {
        if (lang.provider.extractTasks) |extract_fn| {
            const tasks = try extract_fn(allocator, dir_path);
            // Transfer ownership to all_tasks
            try all_tasks.appendSlice(allocator, tasks);
            allocator.free(tasks); // Free the slice wrapper, not the items
        }
    }

    if (all_tasks.items.len > 0) {
        try writer.writeAll("# Auto-detected tasks\n\n");

        for (all_tasks.items) |task| {
            try writer.print(
                \\[tasks.{s}]
                \\description = "{s}"
                \\cmd = "{s}"
                \\
                \\
            , .{ task.name, task.description, task.command });

            // Free allocated strings
            allocator.free(task.name);
            allocator.free(task.command);
            allocator.free(task.description);
        }
    } else {
        // Fallback: add generic tasks
        try writer.writeAll(
            \\# No tasks auto-detected. Add your tasks below.
            \\
            \\[tasks.build]
            \\description = "Build the project"
            \\cmd = "echo 'Add your build command here'"
            \\
            \\[tasks.test]
            \\description = "Run tests"
            \\cmd = "echo 'Add your test command here'"
            \\
            \\
        );
    }

    return try buf.toOwnedSlice(allocator);
}

pub const INIT_TEMPLATE =
    \\# zr.toml — generated by `zr init`
    \\# Docs: https://github.com/yusa-imit/zr
    \\
    \\[tasks.hello]
    \\description = "Print a greeting"
    \\cmd = "echo Hello from zr!"
    \\
    \\[tasks.build]
    \\description = "Build the project"
    \\cmd = "echo Building..."
    \\deps = ["hello"]
    \\
    \\[tasks.test]
    \\description = "Run tests"
    \\cmd = "echo Testing..."
    \\deps = ["build"]
    \\
    \\[tasks.clean]
    \\description = "Remove build artifacts"
    \\cmd = "echo Cleaning..."
    \\allow_failure = true
    \\
;

pub fn cmdInit(
    allocator: std.mem.Allocator,
    dir: std.fs.Dir,
    detect_mode: bool,
    w: *std.Io.Writer,
    err_writer: *std.Io.Writer,
    use_color: bool,
) !u8 {
    // Check whether the config already exists.
    const exists: bool = blk: {
        dir.access(common.CONFIG_FILE, .{}) catch |err| {
            if (err == error.FileNotFound) break :blk false;
            try color.printError(err_writer, use_color,
                "init: Cannot check for existing config: {s}\n", .{@errorName(err)});
            return 1;
        };
        break :blk true;
    };

    if (exists) {
        try color.printError(err_writer, use_color,
            "init: {s} already exists\n\n  Hint: Remove it first or edit it directly\n",
            .{common.CONFIG_FILE});
        return 1;
    }

    // Determine which template to use
    const template = if (detect_mode) blk: {
        try color.printInfo(w, use_color, "Detecting project languages...\n", .{});

        // Get current directory path
        var path_buf: [std.fs.max_path_bytes]u8 = undefined;
        const cwd_path = try dir.realpath(".", &path_buf);

        // Detect languages
        const detected = try registry.detectProjectLanguages(allocator, cwd_path);
        defer {
            for (detected) |*lang| {
                var lang_copy = lang.*;
                lang_copy.deinit(allocator);
            }
            allocator.free(detected);
        }

        if (detected.len == 0) {
            try color.printDim(w, use_color, "No languages detected. Using default template.\n\n", .{});
            // Need to allocate a copy since we'll free it later
            const fallback = try generateConfigFromDetected(allocator, &.{}, cwd_path);
            break :blk fallback;
        }

        // Show detected languages
        try color.printSuccess(w, use_color, "Detected languages:\n", .{});
        for (detected) |lang| {
            try w.print("  - {s} (confidence: {d}%) [", .{ lang.provider.name, lang.confidence });
            for (lang.files_found, 0..) |file, idx| {
                if (idx > 0) try w.print(", ", .{});
                try w.print("{s}", .{file});
            }
            try w.print("]\n", .{});
        }
        try w.print("\n", .{});

        // Generate config from detected languages
        const generated = try generateConfigFromDetected(allocator, detected, cwd_path);
        break :blk generated;
    } else INIT_TEMPLATE;

    defer if (detect_mode) allocator.free(template);

    // Create the config file exclusively (won't overwrite).
    const file = dir.createFile(common.CONFIG_FILE, .{ .exclusive = true }) catch |cerr| {
        try color.printError(err_writer, use_color,
            "init: Failed to create {s}: {s}\n", .{ common.CONFIG_FILE, @errorName(cerr) });
        return 1;
    };

    // Write template. On failure, delete the partial file so the user can retry.
    file.writeAll(template) catch |werr| {
        file.close();
        dir.deleteFile(common.CONFIG_FILE) catch {};
        try color.printError(err_writer, use_color,
            "init: Failed to write {s}: {s}\n", .{ common.CONFIG_FILE, @errorName(werr) });
        return 1;
    };
    file.close();

    try color.printSuccess(w, use_color, "Created {s}\n", .{common.CONFIG_FILE});
    try color.printDim(w, use_color,
        "\nNext steps:\n  zr list          # see available tasks\n  zr run hello     # run the example task\n",
        .{});
    return 0;
}

test "cmdInit creates zr.toml in empty directory" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    var out_buf: [4096]u8 = undefined;
    const stdout = std.fs.File.stdout();
    var out_w = stdout.writer(&out_buf);
    var err_buf: [4096]u8 = undefined;
    const stderr_file = std.fs.File.stderr();
    var err_w = stderr_file.writer(&err_buf);

    // First call: should create the file (no detect mode).
    const code1 = try cmdInit(std.testing.allocator, tmp.dir, false, &out_w.interface, &err_w.interface, false);
    try std.testing.expectEqual(@as(u8, 0), code1);

    // Verify file exists and contains expected content.
    const content = try tmp.dir.readFileAlloc(std.testing.allocator, common.CONFIG_FILE, 4096);
    defer std.testing.allocator.free(content);
    try std.testing.expect(std.mem.indexOf(u8, content, "[tasks.") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "hello") != null);

    // Second call: should refuse to overwrite.
    const code2 = try cmdInit(std.testing.allocator, tmp.dir, false, &out_w.interface, &err_w.interface, false);
    try std.testing.expectEqual(@as(u8, 1), code2);
}

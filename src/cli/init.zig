const std = @import("std");
const color = @import("../output/color.zig");
const common = @import("common.zig");

pub const INIT_TEMPLATE =
    \\# zr.toml â€” generated by `zr init`
    \\# Docs: https://github.com/yusa-imit/zr
    \\
    \\[tasks.hello]
    \\description = "Print a greeting"
    \\cmd = "echo Hello from zr!"
    \\
    \\[tasks.build]
    \\description = "Build the project"
    \\cmd = "echo Building..."
    \\deps = ["hello"]
    \\
    \\[tasks.test]
    \\description = "Run tests"
    \\cmd = "echo Testing..."
    \\deps = ["build"]
    \\
    \\[tasks.clean]
    \\description = "Remove build artifacts"
    \\cmd = "echo Cleaning..."
    \\allow_failure = true
    \\
;

pub fn cmdInit(
    dir: std.fs.Dir,
    w: *std.Io.Writer,
    err_writer: *std.Io.Writer,
    use_color: bool,
) !u8 {
    // Check whether the config already exists.
    const exists: bool = blk: {
        dir.access(common.CONFIG_FILE, .{}) catch |err| {
            if (err == error.FileNotFound) break :blk false;
            try color.printError(err_writer, use_color,
                "init: Cannot check for existing config: {s}\n", .{@errorName(err)});
            return 1;
        };
        break :blk true;
    };

    if (exists) {
        try color.printError(err_writer, use_color,
            "init: {s} already exists\n\n  Hint: Remove it first or edit it directly\n",
            .{common.CONFIG_FILE});
        return 1;
    }

    // Create the config file exclusively (won't overwrite).
    const file = dir.createFile(common.CONFIG_FILE, .{ .exclusive = true }) catch |cerr| {
        try color.printError(err_writer, use_color,
            "init: Failed to create {s}: {s}\n", .{ common.CONFIG_FILE, @errorName(cerr) });
        return 1;
    };

    // Write template. On failure, delete the partial file so the user can retry.
    file.writeAll(INIT_TEMPLATE) catch |werr| {
        file.close();
        dir.deleteFile(common.CONFIG_FILE) catch {};
        try color.printError(err_writer, use_color,
            "init: Failed to write {s}: {s}\n", .{ common.CONFIG_FILE, @errorName(werr) });
        return 1;
    };
    file.close();

    try color.printSuccess(w, use_color, "Created {s}\n", .{common.CONFIG_FILE});
    try color.printDim(w, use_color,
        "\nNext steps:\n  zr list          # see available tasks\n  zr run hello     # run the example task\n",
        .{});
    return 0;
}

test "cmdInit creates zr.toml in empty directory" {
    var tmp = std.testing.tmpDir(.{});
    defer tmp.cleanup();

    var out_buf: [4096]u8 = undefined;
    const stdout = std.fs.File.stdout();
    var out_w = stdout.writer(&out_buf);
    var err_buf: [4096]u8 = undefined;
    const stderr_file = std.fs.File.stderr();
    var err_w = stderr_file.writer(&err_buf);

    // First call: should create the file.
    const code1 = try cmdInit(tmp.dir, &out_w.interface, &err_w.interface, false);
    try std.testing.expectEqual(@as(u8, 0), code1);

    // Verify file exists and contains expected content.
    const content = try tmp.dir.readFileAlloc(std.testing.allocator, common.CONFIG_FILE, 4096);
    defer std.testing.allocator.free(content);
    try std.testing.expect(std.mem.indexOf(u8, content, "[tasks.") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "hello") != null);

    // Second call: should refuse to overwrite.
    const code2 = try cmdInit(tmp.dir, &out_w.interface, &err_w.interface, false);
    try std.testing.expectEqual(@as(u8, 1), code2);
}

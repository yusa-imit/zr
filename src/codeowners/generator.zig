const std = @import("std");
const types = @import("types.zig");
const config_types = @import("../config/types.zig");
const CodeownersConfig = types.CodeownersConfig;
const OwnerPattern = types.OwnerPattern;

/// CODEOWNERS file generator.
pub const Generator = struct {
    allocator: std.mem.Allocator,
    config: *const CodeownersConfig,
    patterns: std.ArrayList(OwnerPattern),

    pub fn init(allocator: std.mem.Allocator, config: *const CodeownersConfig) Generator {
        return .{
            .allocator = allocator,
            .config = config,
            .patterns = std.ArrayList(OwnerPattern){},
        };
    }

    pub fn deinit(self: *Generator) void {
        for (self.patterns.items) |*pattern| {
            pattern.deinit(self.allocator);
        }
        self.patterns.deinit(self.allocator);
    }

    /// Add a pattern manually.
    pub fn addPattern(self: *Generator, pattern: []const u8, owners: []const []const u8) !void {
        const pattern_copy = try self.allocator.dupe(u8, pattern);
        errdefer self.allocator.free(pattern_copy);

        const owners_copy = try self.allocator.alloc([]const u8, owners.len);
        errdefer self.allocator.free(owners_copy);

        for (owners, 0..) |owner, i| {
            owners_copy[i] = try self.allocator.dupe(u8, owner);
        }

        try self.patterns.append(self.allocator, .{
            .pattern = pattern_copy,
            .owners = owners_copy,
        });
    }

    /// Auto-detect ownership from workspace members.
    pub fn detectFromWorkspace(self: *Generator, member_paths: []const []const u8) !void {
        if (!self.config.auto_detect) return;

        for (member_paths) |member_path| {
            // Check if there's a configured owner for this member
            const owners = self.config.member_owners.get(member_path);
            if (owners) |owner_list| {
                // Create pattern: member_path/**
                const pattern = try std.fmt.allocPrint(self.allocator, "{s}/**", .{member_path});
                errdefer self.allocator.free(pattern);

                const owners_copy = try self.allocator.alloc([]const u8, owner_list.len);
                errdefer self.allocator.free(owners_copy);

                for (owner_list, 0..) |owner, i| {
                    owners_copy[i] = try self.allocator.dupe(u8, owner);
                }

                try self.patterns.append(self.allocator, .{
                    .pattern = pattern,
                    .owners = owners_copy,
                });
            }
        }
    }

    /// Generate CODEOWNERS file content.
    pub fn generate(self: *Generator) ![]const u8 {
        var buf = std.ArrayList(u8){};
        errdefer buf.deinit(self.allocator);

        // Header
        try buf.appendSlice(self.allocator, "# This file is auto-generated by zr.\n");
        try buf.appendSlice(self.allocator, "# https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners\n\n");

        // Custom patterns from config
        for (self.config.patterns) |pattern| {
            try writePattern(&buf, self.allocator, pattern.pattern, pattern.owners);
        }

        // Auto-detected patterns
        for (self.patterns.items) |pattern| {
            try writePattern(&buf, self.allocator, pattern.pattern, pattern.owners);
        }

        // Default owners (catch-all at the end)
        if (self.config.default_owners.len > 0) {
            try writePattern(&buf, self.allocator, "*", self.config.default_owners);
        }

        return buf.toOwnedSlice(self.allocator);
    }

    fn writePattern(buf: *std.ArrayList(u8), allocator: std.mem.Allocator, pattern: []const u8, owners: []const []const u8) !void {
        try buf.appendSlice(allocator, pattern);
        for (owners) |owner| {
            try buf.append(allocator, ' ');
            try buf.appendSlice(allocator, owner);
        }
        try buf.append(allocator, '\n');
    }
};

test "Generator init/deinit" {
    const allocator = std.testing.allocator;
    var config = CodeownersConfig.init(allocator);
    defer config.deinit(allocator);

    var gen = Generator.init(allocator, &config);
    defer gen.deinit();
}

test "Generator addPattern" {
    const allocator = std.testing.allocator;
    var config = CodeownersConfig.init(allocator);
    defer config.deinit(allocator);

    var gen = Generator.init(allocator, &config);
    defer gen.deinit();

    const owners = [_][]const u8{ "@team1", "@user1" };
    try gen.addPattern("src/**", &owners);

    try std.testing.expectEqual(@as(usize, 1), gen.patterns.items.len);
    try std.testing.expectEqualStrings("src/**", gen.patterns.items[0].pattern);
    try std.testing.expectEqual(@as(usize, 2), gen.patterns.items[0].owners.len);
}

test "Generator generate basic" {
    const allocator = std.testing.allocator;
    var config = CodeownersConfig.init(allocator);
    defer config.deinit(allocator);

    const default_owner = try allocator.dupe(u8, "@default-team");
    config.default_owners = try allocator.dupe([]const u8, &[_][]const u8{default_owner});

    var gen = Generator.init(allocator, &config);
    defer gen.deinit();

    const owners = [_][]const u8{ "@backend", "@alice" };
    try gen.addPattern("packages/api/**", &owners);

    const content = try gen.generate();
    defer allocator.free(content);

    try std.testing.expect(std.mem.indexOf(u8, content, "# This file is auto-generated by zr.") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "packages/api/** @backend @alice") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "* @default-team") != null);
}

test "Generator detectFromWorkspace" {
    const allocator = std.testing.allocator;
    var config = CodeownersConfig.init(allocator);
    defer config.deinit(allocator);

    // Configure owner for a workspace member
    const member_path = try allocator.dupe(u8, "packages/core");
    const owner_str = try allocator.dupe(u8, "@core-team");
    const owners = try allocator.dupe([]const u8, &[_][]const u8{owner_str});
    try config.member_owners.put(member_path, owners);

    var gen = Generator.init(allocator, &config);
    defer gen.deinit();

    const member_paths = [_][]const u8{"packages/core"};
    try gen.detectFromWorkspace(&member_paths);

    try std.testing.expectEqual(@as(usize, 1), gen.patterns.items.len);
    try std.testing.expectEqualStrings("packages/core/**", gen.patterns.items[0].pattern);
    try std.testing.expectEqual(@as(usize, 1), gen.patterns.items[0].owners.len);
    try std.testing.expectEqualStrings("@core-team", gen.patterns.items[0].owners[0]);
}
